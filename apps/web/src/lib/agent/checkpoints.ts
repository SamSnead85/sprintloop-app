/**
 * Checkpoints System
 * 
 * Phase 112: Version control within agent sessions
 * Rollback to any checkpoint with visual timeline
 * Source: Cline
 */

import { create } from 'zustand';

export interface Checkpoint {
    id: string;
    sessionId: string;
    name: string;
    description?: string;
    timestamp: number;

    // State snapshot
    files: FileSnapshot[];
    terminalHistory: string[];
    agentState: AgentStateSnapshot;

    // Metadata
    agentAction: string;
    isAutoGenerated: boolean;
    tags: string[];
}

export interface FileSnapshot {
    path: string;
    content: string;
    hash: string;
    previousHash?: string;
}

export interface AgentStateSnapshot {
    mode: string;
    planStepIndex: number;
    pendingActions: string[];
    context: Record<string, unknown>;
}

export interface CheckpointDiff {
    checkpointId: string;
    files: FileDiff[];
    summary: string;
}

export interface FileDiff {
    path: string;
    type: 'added' | 'modified' | 'deleted';
    additions: number;
    deletions: number;
    hunks: DiffHunk[];
}

export interface DiffHunk {
    oldStart: number;
    oldLines: number;
    newStart: number;
    newLines: number;
    lines: string[];
}

interface CheckpointState {
    checkpoints: Map<string, Checkpoint[]>; // sessionId -> checkpoints
    currentCheckpointId: string | null;
    autoCheckpoint: boolean;
    maxCheckpointsPerSession: number;

    // Actions
    createCheckpoint: (sessionId: string, options?: {
        name?: string;
        description?: string;
        isAutoGenerated?: boolean;
        tags?: string[];
    }) => string;

    restoreCheckpoint: (checkpointId: string) => Promise<void>;
    deleteCheckpoint: (checkpointId: string) => void;

    // Queries
    getCheckpoints: (sessionId: string) => Checkpoint[];
    getCheckpoint: (checkpointId: string) => Checkpoint | undefined;
    getDiff: (fromId: string, toId: string) => CheckpointDiff | null;

    // Settings
    setAutoCheckpoint: (enabled: boolean) => void;
}

export const useCheckpointStore = create<CheckpointState>((set, get) => ({
    checkpoints: new Map(),
    currentCheckpointId: null,
    autoCheckpoint: true,
    maxCheckpointsPerSession: 50,

    createCheckpoint: (sessionId, options = {}) => {
        const id = `ckpt-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;

        const checkpoint: Checkpoint = {
            id,
            sessionId,
            name: options.name || `Checkpoint ${Date.now()}`,
            description: options.description,
            timestamp: Date.now(),
            files: [], // Would capture actual file states
            terminalHistory: [],
            agentState: {
                mode: 'auto_edit',
                planStepIndex: 0,
                pendingActions: [],
                context: {},
            },
            agentAction: 'checkpoint created',
            isAutoGenerated: options.isAutoGenerated ?? false,
            tags: options.tags || [],
        };

        set(state => {
            const sessionCheckpoints = state.checkpoints.get(sessionId) || [];
            let newCheckpoints = [...sessionCheckpoints, checkpoint];

            // Enforce max checkpoints
            if (newCheckpoints.length > state.maxCheckpointsPerSession) {
                // Keep manual checkpoints, prune oldest auto-generated
                const manual = newCheckpoints.filter(c => !c.isAutoGenerated);
                const auto = newCheckpoints
                    .filter(c => c.isAutoGenerated)
                    .slice(-state.maxCheckpointsPerSession + manual.length);
                newCheckpoints = [...manual, ...auto].sort((a, b) => a.timestamp - b.timestamp);
            }

            const checkpoints = new Map(state.checkpoints);
            checkpoints.set(sessionId, newCheckpoints);

            return { checkpoints, currentCheckpointId: id };
        });

        console.log('[Checkpoints] Created checkpoint:', checkpoint.name);
        return id;
    },

    restoreCheckpoint: async (checkpointId) => {
        const checkpoint = get().getCheckpoint(checkpointId);
        if (!checkpoint) {
            throw new Error(`Checkpoint ${checkpointId} not found`);
        }

        console.log('[Checkpoints] Restoring to checkpoint:', checkpoint.name);

        // In real implementation:
        // 1. Restore file contents
        // 2. Reset terminal state
        // 3. Restore agent state

        for (const file of checkpoint.files) {
            console.log(`[Checkpoints] Would restore: ${file.path}`);
            // await writeFile(file.path, file.content);
        }

        set({ currentCheckpointId: checkpointId });
    },

    deleteCheckpoint: (checkpointId) => {
        set(state => {
            const checkpoints = new Map(state.checkpoints);

            for (const [sessionId, sessionCheckpoints] of checkpoints.entries()) {
                const filtered = sessionCheckpoints.filter(c => c.id !== checkpointId);
                if (filtered.length !== sessionCheckpoints.length) {
                    checkpoints.set(sessionId, filtered);
                }
            }

            return { checkpoints };
        });
    },

    getCheckpoints: (sessionId) => {
        return get().checkpoints.get(sessionId) || [];
    },

    getCheckpoint: (checkpointId) => {
        for (const sessionCheckpoints of get().checkpoints.values()) {
            const checkpoint = sessionCheckpoints.find(c => c.id === checkpointId);
            if (checkpoint) return checkpoint;
        }
        return undefined;
    },

    getDiff: (fromId, toId) => {
        const from = get().getCheckpoint(fromId);
        const to = get().getCheckpoint(toId);

        if (!from || !to) return null;

        const diff: CheckpointDiff = {
            checkpointId: toId,
            files: [],
            summary: `Changes from "${from.name}" to "${to.name}"`,
        };

        // Compare file snapshots
        const fromFiles = new Map(from.files.map(f => [f.path, f]));
        const toFiles = new Map(to.files.map(f => [f.path, f]));

        // Check for modifications and additions
        for (const [path, toFile] of toFiles) {
            const fromFile = fromFiles.get(path);

            if (!fromFile) {
                diff.files.push({
                    path,
                    type: 'added',
                    additions: toFile.content.split('\n').length,
                    deletions: 0,
                    hunks: [],
                });
            } else if (fromFile.hash !== toFile.hash) {
                diff.files.push({
                    path,
                    type: 'modified',
                    additions: 0, // Would compute actual diff
                    deletions: 0,
                    hunks: [],
                });
            }
        }

        // Check for deletions
        for (const [path] of fromFiles) {
            if (!toFiles.has(path)) {
                const fromFile = fromFiles.get(path)!;
                diff.files.push({
                    path,
                    type: 'deleted',
                    additions: 0,
                    deletions: fromFile.content.split('\n').length,
                    hunks: [],
                });
            }
        }

        return diff;
    },

    setAutoCheckpoint: (enabled) => {
        set({ autoCheckpoint: enabled });
    },
}));

/**
 * Create automatic checkpoint before destructive action
 */
export function autoCheckpointBeforeAction(
    sessionId: string,
    action: string
): string {
    const store = useCheckpointStore.getState();

    if (!store.autoCheckpoint) {
        return '';
    }

    return store.createCheckpoint(sessionId, {
        name: `Before: ${action}`,
        isAutoGenerated: true,
        tags: ['auto', 'before-action'],
    });
}

/**
 * Create checkpoint after successful action
 */
export function checkpointAfterAction(
    sessionId: string,
    action: string
): string {
    const store = useCheckpointStore.getState();

    return store.createCheckpoint(sessionId, {
        name: `After: ${action}`,
        isAutoGenerated: true,
        tags: ['auto', 'after-action'],
    });
}

/**
 * Get timeline of checkpoints for visualization
 */
export function getCheckpointTimeline(sessionId: string): {
    checkpoints: Checkpoint[];
    current: Checkpoint | null;
} {
    const store = useCheckpointStore.getState();
    const checkpoints = store.getCheckpoints(sessionId);
    const current = store.currentCheckpointId
        ? store.getCheckpoint(store.currentCheckpointId)
        : null;

    return {
        checkpoints: checkpoints.sort((a, b) => a.timestamp - b.timestamp),
        current: current ?? null,
    };
}
